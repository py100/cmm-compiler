[terminal]
	BREAK
	CHAR
	CONTINUE
	DOUBLE
	ELSE
	FLOAT
	FOR
	IF
	INT
	LONG
	RETURN
	SHORT
	SIGNED
	TYPEDEF
	UNSIGNED
	VOID
	WHILE
	INCLUDE
	IDENTIFIER
	INT_VAL
	CHAR_VAL
	FLOAT_VAL
	STRING_VAL
	*
	/
	%
	+
	-
	<
	>
	=
	++
	--
	<=
	>=
	!=
	&&
	||
	==
	!
	OP_OTHERS
	CONST_STR
	(
	)
	[
	]
	{
	}
	'
	"
	:
	;
	,
	#
[nonterminal]
	program'
	program
	main_declaration
	type_specifier
	compound_statement
	declaration_list
	declaration
	initializer
	declaration_type
	init_declarator_list
	init_declarator
	declarator
	statement_list
	statement
	expression_statement
	expression
	assignment_expression
	condition_expression
	unary_expression
	logical_or_expression
	logical_and_expression
	inclusive_or_expression
	exclusive_or_expression
	and_expression
	equality_expression
	relational_expression
	additive_expression
	multiplicative_expression
	postfix_expression
	primary_expression
	iteration_statement
	jump_statement
	selection_statement
[start]
	program'
[production]
	program' =>
		program ;

	program =>
		main_declaration ;

	main_declaration =>
		type_specifier IDENTIFIER '(' ')' compound_statement ;

	type_specifier =>
		VOID
		| CHAR
		|	INT
		| FLOAT ;

	compound_statement =>
		'{' '}'
		| '{' declaration_list '}'
		| '{' statement_list '}'
		| '{' declaration_list statement_list '}' ;

	declaration_list =>
		declaration_type
		| declaration_list declaration_type ;

	declaration_type =>
		type_specifier init_declarator_list ';' ;

	init_declarator_list =>
		init_declarator
		|	init_declarator_list ',' init_declarator ;

	init_declarator =>
		declarator
		| declarator '=' initializer ;

	declarator =>
		IDENTIFIER ;

	initializer =>
		INT_VAL
		| CHAR_VAL
		| FLOAT_VAL
		| STRING_VAL ;

	statement_list =>
		statement
		| statement_list statement ;

	statement =>
		compound_statement
		| expression_statement 
		|	iteration_statement 
		|	jump_statement 
		|	selection_statement ;

	expression_statement =>
		';'
		| expression ';' ;

	expression =>
		assignment_expression ;

	assignment_expression =>
		initializer
		| IDENTIFIER '=' assignment_expression
		|	logical_or_expression ;

	logical_or_expression =>
		logical_and_expression
		|	logical_or_expression || logical_and_expression ;

	logical_and_expression =>
		equality_expression
		|	logical_and_expression && equality_expression ;

	equality_expression =>
		relational_expression
		|	equality_expression == relational_expression
		|	equality_expression != relational_expression ;

	relational_expression =>
		additive_expression
		| relational_expression '<' additive_expression
   	| relational_expression '>' additive_expression
   	| relational_expression <= additive_expression
   	| relational_expression >= additive_expression ;

  additive_expression =>
  	multiplicative_expression
  	| additive_expression '+' multiplicative_expression
  	| additive_expression '-' multiplicative_expression ;

  multiplicative_expression =>
   	unary_expression
   	| multiplicative_expression '*' unary_expression
   	| multiplicative_expression '/' unary_expression
   	| multiplicative_expression '%' unary_expression ;

  unary_expression =>
  	IDENTIFIER
  	|	initializer ;

  iteration_statement =>
  	WHILE '(' expression ')' compound_statement
  	|	FOR '(' expression_statement expression_statement expression ')' compound_statement ;

  jump_statement =>
  	CONTINUE ';'
  	|	BREAK ';'
  	|	RETURN ';'
  	|	RETURN expression ';' ;

  selection_statement =>
  	IF '(' expression ')' statement
  	|	IF '(' expression ')' statement ELSE statement ;
 
